\contentsline {chapter}{\numberline {1}Background and Motivation: Why Tabling?}{1}
\contentsline {chapter}{\numberline {2}Introduction to Prolog}{6}
\contentsline {section}{\numberline {2.1}Prolog as a Procedural Programming Language}{6}
\contentsline {subsection}{\numberline {2.1.1}Assign-once Variables}{7}
\contentsline {subsection}{\numberline {2.1.2}Nondeterminism}{11}
\contentsline {subsubsection}{Prolog execution as the execution of multiple machines}{12}
\contentsline {subsection}{\numberline {2.1.3}Executing Programs in XSB}{13}
\contentsline {subsection}{\numberline {2.1.4}The Scheduling of Machine Execution in Prolog}{18}
\contentsline {section}{\numberline {2.2}Grammars in Prolog}{21}
\contentsline {section}{\numberline {2.3}Prolog as a Database Query Langauge}{26}
\contentsline {section}{\numberline {2.4}Deductive Databases}{27}
\contentsline {section}{\numberline {2.5}Summary}{30}
\contentsline {section}{\numberline {2.6}Exercises}{30}
\contentsline {section}{\numberline {2.7}Exercise Discussion}{32}
\contentsline {chapter}{\numberline {3}Introduction to First-Order Logic}{34}
\contentsline {section}{\numberline {3.1}Propositional Logic}{36}
\contentsline {subsection}{\numberline {3.1.1}Syntax}{36}
\contentsline {subsection}{\numberline {3.1.2}Semantics}{36}
\contentsline {subsection}{\numberline {3.1.3}Deduction}{38}
\contentsline {subsubsection}{Soundness}{39}
\contentsline {subsubsection}{Completeness}{40}
\contentsline {subsection}{\numberline {3.1.4}Horn Clauses}{41}
\contentsline {subsubsection}{Horn Clauses, Unit Resolution}{43}
\contentsline {section}{\numberline {3.2}First Order Logic (FOL)}{44}
\contentsline {subsection}{\numberline {3.2.1}Syntax}{44}
\contentsline {subsection}{\numberline {3.2.2}Semantics}{46}
\contentsline {subsection}{\numberline {3.2.3}Deduction}{49}
\contentsline {subsubsection}{Resolution in FOL}{51}
\contentsline {subsubsection}{Horn Clauses, SLD}{54}
\contentsline {subsubsection}{Prolog as FO Horn Clauses}{54}
\contentsline {subsubsection}{Limitations of Prolog/SLD and what can be done}{54}
\contentsline {section}{\numberline {3.3}Exercises}{58}
\contentsline {chapter}{\numberline {4}Tabling and Datalog Programming}{63}
\contentsline {subsubsection}{XSB tabled execution as the execution of concurrent machines}{64}
\contentsline {section}{\numberline {4.1}More on Transitive Closure}{68}
\contentsline {section}{\numberline {4.2}Other Datalog Examples}{72}
\contentsline {section}{\numberline {4.3}Some Simple Graph Problems}{73}
\contentsline {subsection}{\numberline {4.3.1}Stongly Connected Components in a DAG}{73}
\contentsline {subsection}{\numberline {4.3.2}Connected Components in an Undirected Graph}{74}
\contentsline {section}{\numberline {4.4}Genome Examples}{75}
\contentsline {section}{\numberline {4.5}Subsumptive Tabling}{75}
\contentsline {section}{\numberline {4.6}Inferring When to Table}{75}
\contentsline {subsubsection}{On the Complexity of Tabled Datalog Programs}{78}
\contentsline {section}{\numberline {4.7}Datalog Optimization in XSB}{80}
\contentsline {section}{\numberline {4.8}Table Builtins}{80}
\contentsline {section}{\numberline {4.9}Exercises}{81}
\contentsline {chapter}{\numberline {5}Prolog Programs as Inductive Definitions}{84}
\contentsline {section}{\numberline {5.1}Introduction}{84}
\contentsline {section}{\numberline {5.2}Motivation}{85}
\contentsline {section}{\numberline {5.3}Informal Review of Inductive Definitions}{85}
\contentsline {section}{\numberline {5.4}Finite, Labeled, Ordered Trees}{86}
\contentsline {section}{\numberline {5.5}Inductive Definitions of Sets of Trees}{88}
\contentsline {section}{\numberline {5.6}Evaluation of Inductive Programs}{91}
\contentsline {subsection}{\numberline {5.6.1}Top-Down Computation}{93}
\contentsline {subsection}{\numberline {5.6.2}Lazy Grounding in Top-Down Computation}{101}
\contentsline {section}{\numberline {5.7}Conclusion}{104}
\contentsline {chapter}{\numberline {6}Grammars}{105}
\contentsline {section}{\numberline {6.1}An Expression Grammar}{105}
\contentsline {section}{\numberline {6.2}Representing the Input String as Facts}{107}
\contentsline {section}{\numberline {6.3}Mixing Tabled and Prolog Evaluation}{109}
\contentsline {section}{\numberline {6.4}So What Kind of Parser is it?}{110}
\contentsline {section}{\numberline {6.5}Building Parse Trees}{111}
\contentsline {section}{\numberline {6.6}Computing First Sets of Grammars}{114}
\contentsline {section}{\numberline {6.7}Linear Parsing of LL(k) and LR(k) Grammars}{116}
\contentsline {section}{\numberline {6.8}Parsing of Context Sensitive Grammars}{120}
\contentsline {section}{\numberline {6.9}Substring Matching}{124}
\contentsline {section}{\numberline {6.10}Exercises}{127}
\contentsline {chapter}{\numberline {7}Automata Theory in XSB}{130}
\contentsline {section}{\numberline {7.1}Finite State Machines}{130}
\contentsline {subsection}{\numberline {7.1.1}Intersection of FSM's}{133}
\contentsline {subsection}{\numberline {7.1.2}Epsilon-free FSM's}{134}
\contentsline {subsection}{\numberline {7.1.3}Deterministic FSM's}{136}
\contentsline {subsection}{\numberline {7.1.4}Complements of FSM's}{138}
\contentsline {subsection}{\numberline {7.1.5}Minimization of FSM's}{141}
\contentsline {subsection}{\numberline {7.1.6}Regular Expressions}{145}
\contentsline {section}{\numberline {7.2}Grammars Revisited}{148}
\contentsline {section}{\numberline {7.3}Push-Down Automata}{150}
\contentsline {section}{\numberline {7.4}Exercises}{150}
\contentsline {chapter}{\numberline {8}Dynamic Programming in XSB}{152}
\contentsline {section}{\numberline {8.1}The Knap-Sack Problem}{152}
\contentsline {section}{\numberline {8.2}Sequence Comparisons}{154}
\contentsline {section}{\numberline {8.3}??}{155}
\contentsline {section}{\numberline {8.4}Exercises}{155}
\contentsline {chapter}{\numberline {9}Tabling for Initialization and Indexing}{156}
\contentsline {section}{\numberline {9.1}abstract}{156}
\contentsline {section}{\numberline {9.2}Introduction}{156}
\contentsline {section}{\numberline {9.3}Brief Review of Top-Down and Bottom-up Evaluation}{157}
\contentsline {section}{\numberline {9.4}Example of Need for Bottom-Up Evaluation}{158}
\contentsline {section}{\numberline {9.5}Specifying Bottom-Up Evaluation in XSB}{159}
\contentsline {section}{\numberline {9.6}Intermixing Top-down and Bottom-up evaluation}{161}
\contentsline {section}{\numberline {9.7}Procedural Interpretation of Bottom-up Evaluation}{162}
\contentsline {section}{\numberline {9.8}STWA for File Input}{163}
\contentsline {section}{\numberline {9.9}Does Subsumptive Tabling with Abstraction (STWA) Really Do Bottom-Up Evaluation?}{164}
\contentsline {section}{\numberline {9.10}Bottom-up Proofs for Propositional Horn Clauses in Linear Time}{166}
\contentsline {section}{\numberline {9.11}Performance of XSB STWA for Bottom-Up Evaluation}{168}
\contentsline {section}{\numberline {9.12}Conclusion}{170}
\contentsline {section}{\numberline {9.13}Programs to Generate Traces}{170}
\contentsline {section}{\numberline {9.14}Subsumptive Tabling with Full Abstraction (STWFA) is Bottom-up}{171}
\contentsline {subsection}{\numberline {9.14.1}Multiple Machine Model of Tabled Horn Clause Evaluation}{171}
\contentsline {subsection}{\numberline {9.14.2}Example of STWFA Evaluation}{172}
\contentsline {subsection}{\numberline {9.14.3}Relationship of STWFA and Bottom-Up}{180}
\contentsline {chapter}{\numberline {10}HiLog Programming}{183}
\contentsline {section}{\numberline {10.1}Generic Programs}{183}
\contentsline {section}{\numberline {10.2}Object Centered Programming in XSB with HiLog}{187}
\contentsline {chapter}{\numberline {11}Debugging Tabled Programs}{188}
\contentsline {chapter}{\numberline {12}Aggregation}{190}
\contentsline {section}{\numberline {12.1}Tabled Agggregation and Lattice Operations: Min, Max}{191}
\contentsline {section}{\numberline {12.2}Tabled Agggregation and the Fold Operation: sum}{192}
\contentsline {section}{\numberline {12.3}Paths with Maximal Numbers of Edges}{197}
\contentsline {section}{\numberline {12.4}Recursive Aggregation}{199}
\contentsline {subsection}{\numberline {12.4.1}Shortest Path}{199}
\contentsline {subsection}{\numberline {12.4.2}Reasoning with Uncertainty: Annotated Logic}{200}
\contentsline {subsection}{\numberline {12.4.3}Longest Path}{201}
\contentsline {subsection}{\numberline {12.4.4}Markov Decision Processes}{201}
\contentsline {section}{\numberline {12.5}Scheduling Issues}{203}
\contentsline {section}{\numberline {12.6}Stratified Aggregation}{203}
\contentsline {chapter}{\numberline {13}Incremental Table Maintenance}{204}
\contentsline {chapter}{\numberline {14}Negation in XSB}{205}
\contentsline {section}{\numberline {14.1}Completion Semantics}{209}
\contentsline {section}{\numberline {14.2}Negation through Fixed Points}{212}
\contentsline {section}{\numberline {14.3}General Negation}{218}
\contentsline {subsection}{\numberline {14.3.1}Clark's Completion Semantics}{219}
\contentsline {subsection}{\numberline {14.3.2}Stable Model Semantics}{221}
\contentsline {subsection}{\numberline {14.3.3}Well-Founded Semantics}{223}
\contentsline {section}{\numberline {14.4}Other Stuff to think about?}{228}
\contentsline {section}{\numberline {14.5}Approximate Reasoning}{228}
\contentsline {section}{\numberline {14.6}Representation of Partial Knowledge with Well-Founded Models}{229}
\contentsline {chapter}{\numberline {15}Meta-Programming}{234}
\contentsline {section}{\numberline {15.1}Meta-Interpreters in XSB}{234}
\contentsline {subsection}{\numberline {15.1.1}A Metainterpreter for Disjunctive Logic Programs}{234}
\contentsline {subsection}{\numberline {15.1.2}A Metainterpreter for Explicit Negation}{234}
\contentsline {section}{\numberline {15.2}Abstract Interpretation}{234}
\contentsline {subsection}{\numberline {15.2.1}AI of a Simple Nested Procedural Language}{235}
\contentsline {chapter}{\numberline {16}XSB Modules}{240}
\contentsline {chapter}{\numberline {17}Handling Large Fact Files}{241}
\contentsline {section}{\numberline {17.1}Indexing}{241}
\contentsline {section}{\numberline {17.2}Compiling Fact Files}{244}
\contentsline {section}{\numberline {17.3}Dynamically Loaded Fact Files}{245}
\contentsline {section}{\numberline {17.4}Indexing Static Program Clauses}{246}
\contentsline {chapter}{\numberline {18}Programming with Sets}{248}
\contentsline {section}{\numberline {18.1}Introduction}{248}
\contentsline {section}{\numberline {18.2}Interned (or HashCons-ed) Terms}{248}
\contentsline {section}{\numberline {18.3}The prolog\_db Data Structure}{248}
\contentsline {section}{\numberline {18.4}Conclusion (or Summary?)}{249}
\contentsline {chapter}{\numberline {19}Managing Large, Updatable State}{250}
\contentsline {section}{\numberline {19.1}Introduction}{250}
\contentsline {section}{\numberline {19.2}The prolog\_db Data Structure}{250}
\contentsline {section}{\numberline {19.3}Examples}{250}
\contentsline {section}{\numberline {19.4}Conclusion (or Summary?)}{251}
\contentsline {chapter}{\numberline {20}XSB System Facilities}{252}
